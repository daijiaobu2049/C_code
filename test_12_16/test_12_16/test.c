#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <string.h>

//int main()
//{
//	char* p = "abcdef";
//	printf("%zd\n", strlen(p));//6
//	//字符串的长度
//	printf("%zd\n", strlen(p + 1));//5
//	//往后移一位
//	//printf("%d\n", strlen(*p));//err      是首元素的地址'a'--'97'
//	//printf("%d\n", strlen(p[0]));//err    是首元素的地址'a'--'97'
//	printf("%zd\n", strlen(&p));//随机值
//	
//	printf("%zd\n", strlen(&p + 1));//随机值
//
//	printf("%zd\n", strlen(&p[0] + 1));//5
//	return 0;
//}



//二维数组

//int main()
//{
//	int a[3][4] = { 0 };
//	printf("%zd\n", sizeof(a));//48
//	//a作为数组名，单独放在sizeof内部，表示的是整个数组，计算的是整个数组的大小
//	printf("%zd\n", sizeof(a[0][0]));//4
//	//a[0][0]是第一行第一个元素，大小4个字节
//	printf("%zd\n", sizeof(a[0]));//16
//	//a[0]是第一行的数组名，单独放在sizeof内部，计算的是第一行数组的大小
//	printf("%zd\n", sizeof(a[0] + 1));//4/8
//	//a[0]是第一行的数组名，但是没有单独放在sizeof内部，那么只能是数组首元素的地址，那就是第一行第一个元素的地址
//	//&a[0][0]          a[0] + 1 == &a[0][0] + 1 == &a[0][1]
//	//地址的大小就是 - 4/8
//	printf("%zd\n", sizeof(*(a[0] + 1)));//4
//	//a[0] + 1 == &a[0][0] + 1 == &a[0][1]  就是第一行的第二个元素的大小
//	printf("%zd\n", sizeof(a + 1));//4/8
//	//a是二维数组的数组名，并没有单数放在sizeof内部，a表示首元素地址，也就是第一行的地址
//	//a+1是第二行的地址，是地址大小就是4/8
//	printf("%zd\n", sizeof(*(a + 1)));//16
//	//1. *(a + 1) -- a[1] -- 是第二行的数组名，单独放在sizeof内部，计算的是第二行的大小
//	//2. a+1是第二行的地址，类型是int(*)[4]，数组指针，解引用访问的是这个数组，大小是16个字节
//	printf("%zd\n", sizeof(&a[0] + 1));//4/8
//	//a[0]是第1行的数组名，&数组名其实就是第一行的地址，&a[0]+1就是第二行的地址，是地址就是4/8
//	printf("%zd\n", sizeof(*(&a[0] + 1)));//16
//	//a[0]是第1行的数组名，&数组名其实就是第一行的地址，&a[0]+1就是第二行的地址，*(&a[0] + 1)就是第二行的元素
//	printf("%zd\n", sizeof(*a));//16
//	//1. a - 首元素的地址（第一行的地址），*a是第一行
//	//2. *a -- *(a+0) -- a[0]
//	printf("%zd\n", sizeof(a[3]));//16
//	//sizeof内部的表达式是不会真实计算的
//	//a[3] - 第四行的数组名 int [4]
//	return 0;
//}


//1. sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。
//2. & 数组名，这里的数组名表示整个数组，取出的是整个数组的地址。
//3. 除此之外所有的数组名都表示首元素的地址。



//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int* ptr = (int*)(&a + 1);
//	printf("%d,%d", *(a + 1), *(ptr - 1));
//	return 0;
//}
////程序的结果是什么？



//在X86环境下
//假设结构体的大小是20个字节
//程序输出的结果是啥？

//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p = (struct Test*)0x100000;
//
//int main()
//{
//	printf("%p\n", p + 0x1);//0x100014
//	//*p是一个结构体指针，+1就是跳过一个结构体，一个结构体就是20个字节
//	printf("%p\n", (unsigned long)p + 0x1);//0x100001
//	//整数+1
//	printf("%p\n", (unsigned int*)p + 0x1);//0x100004
//	//+1跳过一个unsigned int类型的变量，是4个字节
//	return 0;
//}



//int main()
//{
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
//	//逗号表达式取最后那个元素  int a[3][2] = { ( 1), ( 3), ( 5) };
//	//创建二维数组应该是int a[3][2] = { {0, 1}, {2, 3}, {4, 5} };
//	int* p;
//	p = a[0];
//	printf("%d", p[0]);
//	return 0;
//}



//假设环境是x86环境，程序输出的结果是啥？

int main()
{
	int a[5][5];
	int(*p)[4];
	//
	p = a;
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	return 0;
}